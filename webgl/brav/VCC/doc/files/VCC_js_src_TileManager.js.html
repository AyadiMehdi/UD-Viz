<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>VCC/js/src/TileManager.js - Virtual City Client</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Virtual City Client"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/FirstPersonControls.html">FirstPersonControls</a></li>
            
                <li><a href="../classes/VCC.Enum.html">VCC.Enum</a></li>
            
                <li><a href="../classes/VCC.Scheduler.html">VCC.Scheduler</a></li>
            
                <li><a href="../classes/VCC.SchedulerTask.html">VCC.SchedulerTask</a></li>
            
                <li><a href="../classes/VCC.TexturesManager.html">VCC.TexturesManager</a></li>
            
                <li><a href="../classes/VCC.Tile.html">VCC.Tile</a></li>
            
                <li><a href="../classes/VCC.TileManager.html">VCC.TileManager</a></li>
            
                <li><a href="../classes/VCC.ViewPort.html">VCC.ViewPort</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: VCC/js/src/TileManager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
 /**
 * Class that will handle tile management witch means requests to get tiles, creating meshes, class textures...
 *
 * @class VCC.TileManager
 * @author Alexandre Vienne
 * @constructor
 * @param {THREE.Object3D} root Parent object of the Scene Graph.
 * @param {int} sizetile Size of the tile.
 * @param {int} rangeCameraTile How far does we need to lead tiles wr to the main tile.
 * @param {int} mainTileX X coordinates of the tile that we want to create first
 * @param {int} mainTileY  Y coordinates of the tile that we want to create first
 * @param {int} BBmin Bounding Box minimum coordinate
 * @param {int} BBmax Bounding Box maximum coordinate
 **/
VCC.TileManager = function (root,sizeTile,rangeCameraTile,mainTileRow,mainTileCol,BBMin,BBMax){
	if(root == null){
		return;
	}
	this._root = root;

	/**
	* Default URL parameters to construct the request getTile.
	* @property urlParameters
	* @type Object
	*/
	this.urlParameters = {SERVICE: &quot;W3DS&quot;,REQUEST: &quot;GetTile&quot;, VERSION: &quot;0.4.0&quot;,CRS: &quot;lambert93&quot;, LAYER: &quot;build&quot;,FORMAT: &quot;application/json&quot;,TILELEVEL: &quot;2&quot;,TILEROW:&quot;&quot;, TILECOL:&quot;&quot; };
	//Tile de 500*500 soit 1 metre = 0.1

 	/**
	* Size of a tile
	* @property sizeTile
	* @type int
	*/
	this.sizeTile = sizeTile;

	/**
	* How far the tiles will be loaded
	* @property rangeCameraTile
	* @type int
	*/
	this.rangeCameraTile = rangeCameraTile ;

	/**
	* X coordinate of the main tile (in Json file coordinates)
	* @property mainTileX
	* @type int
	*/
	this.mainTileX = mainTileRow;

	/**
	* Y coordinate of the main tile (in Json file coordinates)
	* @property mainTileY
	* @type int
	*/
	this.mainTileY = mainTileCol;

	/** HotFix to make update main tile coodinate calculation work*/
	this.firstTileX = mainTileRow;
	this.firstTileY = mainTileCol;

	this.BBMin = BBMin;
	this.BBMax = BBMax;

	/**
	* Array containing all Tiles loadded
	* @property tabTile
	* @type Array&lt;VCC.Tile&gt;
	*/
	this.tabTile = [];


	this.TileMaxX = parseInt((this.BBMax[0]-this.BBMin[0])/this.sizeTile)-1;
	this.TileMaxY = parseInt((this.BBMax[1]-this.BBMin[1])/this.sizeTile)-1;

	/**
	*Current LOD of the scene
	* @property sceneLod
	* @type int
	*/
	this.sceneLod = 0;

	/**
	*Previous LOD of the scene
	* @property previousLod
	* @type int
	*/
	this.previousLod = 0;

	/**
	*Scheduler for request priorities
	* @property scheduler
	* @type VCC.Scheduler
	*/
	this.scheduler = new VCC.Scheduler();

};

/**
* Check if the tile exists
* @method tileExist
* @return {bollean}
*/

VCC.TileManager.prototype.tileExist = function(idTile){
	return (this.tabTile[idTile] !== undefined);
};

/**
* Handle tiling management with respect to the range cameraTile property and LOD Strategy. Calls to the create Tile function
* @method tilePriorityManager
*
*/


VCC.TileManager.prototype.tilePriorityManager = function() {

	var idTile = this.mainTileX+&quot;_&quot;+this.mainTileY;
	if (!this.tileExist(idTile)){
		var task= new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_GEOM,this.mainTileX,this.mainTileY,&quot;dem&quot;);
		task.addToScheduler(true);
		task= new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_GEOM,this.mainTileX,this.mainTileY,&quot;build&quot;);
		task.addToScheduler(true);
		task = new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_TEXTURE,this.mainTileX,this.mainTileY);
		task.addToScheduler(true);

	}
	var surroundingTilesIds = this.getSurroundingTilesIds();
	for (id in surroundingTilesIds){
		if (!this.tileExist(surroundingTilesIds[id][0]+&quot;_&quot;+surroundingTilesIds[id][1])){
			var task=new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_GEOM,surroundingTilesIds[id][0],surroundingTilesIds[id][1],&quot;build&quot;);
			task.addToScheduler(false);
			task=new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_GEOM,surroundingTilesIds[id][0],surroundingTilesIds[id][1],&quot;dem&quot;);
			task.addToScheduler(true);
		}
	}
	for (id in surroundingTilesIds){
		var tileRow=surroundingTilesIds[id][0];
		var tileCol=surroundingTilesIds[id][1];
		var tileId=tileRow+&quot;_&quot;+tileCol;
		if (!VCC.ViewPort.tileManager.tabTile[tileId].texturesManager.isScheduled){
			VCC.ViewPort.tileManager.tabTile[tileId].texturesManager.isScheduled=true;
			var task=new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_TEXTURE,tileRow,tileCol);
			task.addToScheduler(false);
			task=new VCC.SchedulerTask(VCC.Enum.SCHEDULER_TASK.ST_LOAD_TEXTURE,tileRow,tileCol);
			task.addToScheduler(true);
		}
	}
};

/**
* Computes the surrounding tiles of the camera
* @method getSurroundingTilesIds
* @return {Array} tileRow and tileCol of the 3 surrounding tiles
*/
VCC.TileManager.prototype.getSurroundingTilesIds = function()
{
	var surroundingTilesIds = [];
	var mainTile = this.tabTile[this.mainTileX+&quot;_&quot;+this.mainTileY];
	if(mainTile === undefined){
		return [];
	}

	var middleX = parseInt((mainTile.BBMin[0]+mainTile.BBMax[0])/2 - VCC.ViewPort.tileManager.BBMin[0]);
	var middleY = parseInt((mainTile.BBMin[1]+mainTile.BBMax[1])/2 - VCC.ViewPort.tileManager.BBMin[1]);
	var mask = 0;
	 if(middleX &lt; VCC.ViewPort.camera.position.x){
	 	mask += 1;
	 }
	if(middleY &lt; VCC.ViewPort.camera.position.z){
		mask += 2;
	}

	switch (mask){
		case 0 :surroundingTilesIds.push([this.mainTileX,this.mainTileY-1]);
				surroundingTilesIds.push([this.mainTileX-1,this.mainTileY]);
				surroundingTilesIds.push([this.mainTileX-1,this.mainTileY-1]);
				break;
		case 1 :surroundingTilesIds.push([this.mainTileX+1,this.mainTileY-1]);
				surroundingTilesIds.push([this.mainTileX,this.mainTileY-1])
				surroundingTilesIds.push([this.mainTileX+1,this.mainTileY]);
				break;
		case 2 :surroundingTilesIds.push([this.mainTileX-1,this.mainTileY]);
				surroundingTilesIds.push([this.mainTileX-1,this.mainTileY+1]);
				surroundingTilesIds.push([this.mainTileX,this.mainTileY+1]);
				break;

		case 3 :surroundingTilesIds.push([this.mainTileX+1,this.mainTileY+1]);
				surroundingTilesIds.push([this.mainTileX,this.mainTileY+1]);
				surroundingTilesIds.push([this.mainTileX+1,this.mainTileY]) ;
				break;
		default:
				console.log(&quot;mask error&quot;);
				return surroundingTilesIds;
	}
	return surroundingTilesIds;
};
/**
* rebuild scene with a new lod quality
* @TODO: rewrite to make it work with the new scheduler
* @method reloadWithNewLod
*/

VCC.TileManager.prototype.reloadWithNewLod = function(){
	//delete the scene
	for(var idTile in this.tabTile)
	{
		this.deleteTile(idTile,this.previousLod);
	}
	this.updateMainTile();
};

/**
* Request and create a textured Tile
* @method testTileTexture
* @param {String} tileRow identifier of the tile row (described in Json)
* @param {String} tileCol identifier of the tile column (described in Json)
* @param {String} layer   layer wanted, here &quot;build&quot; or &quot;dem&quot;
*/

VCC.TileManager.prototype.createTile = function (tileRow,tileCol,layer){

	this.urlParameters[&quot;REQUEST&quot;]   = &quot;GetTile&quot;;
	this.urlParameters[&quot;LAYER&quot;]     = layer;
	this.urlParameters[&quot;TILELEVEL&quot;] = &quot;2&quot;;
	this.urlParameters[&quot;TILEROW&quot;]   = tileRow;
	this.urlParameters[&quot;TILECOL&quot;]   = tileCol;

	var urlServer =VCC.ViewPort.serverUrl+&quot;/api/kvp?&quot;;

	for (var key in this.urlParameters)
	{
		urlServer+= key+&quot;=&quot;+this.urlParameters[key]+&quot;&amp;&quot;;
	}
	//remove last &quot;&amp;&quot;
	urlServer = urlServer.substring(0, urlServer.length - 1);

	var json = $.ajax({
			url: urlServer,
			dataType: &#x27;json&#x27;,
			async : true,
			success: function()
			{
				try{
		 			var jsonParsed = JSON.parse(json.responseText);
		 		}catch(e)
		 		{
		 			console.error(&quot;Parsing error:&quot;, e);
		 		}
		 		var tile = VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol];
		 		var addMeshBuildingsToScene = false; 
		 		var addMeshTerrainToScene = false;
		 		var geom = new THREE.Geometry();
		 		if (jsonParsed.listBldg !== undefined &amp;&amp; !jQuery.isEmptyObject(jsonParsed.listBldg))
		 		{
		 			for(b in jsonParsed.listBldg){
		 				var wallArrayGeom = VCC.ViewPort.tileManager.createGeometries(jsonParsed.listBldg[b].walls, tile.texturesManager,tile.indexBuildingMaterialList);
		 				var roofArrayGeom = VCC.ViewPort.tileManager.createGeometries(jsonParsed.listBldg[b].roofs, tile.texturesManager,tile.indexBuildingMaterialList);
						geom.merge(wallArrayGeom);
						geom.merge(roofArrayGeom);
					}
					addMeshBuildingsToScene = true;
					VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol] = tile;

		 		 }else if (jsonParsed.listTerrain !== undefined &amp;&amp; !jQuery.isEmptyObject(jsonParsed.listTerrain)){
		 		 	for(t in jsonParsed.listTerrain){
		 		 		var terrainGeom = VCC.ViewPort.tileManager.createGeometries(jsonParsed.listTerrain[t].terrain, tile.texturesManager, tile.indexTerrainMaterialList);
		 		 		geom.merge(terrainGeom);
		 		 		addMeshTerrainToScene = true;
				 	}
				 	tile.BBMin = jsonParsed.min;
					tile.BBMax = jsonParsed.max;
					VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol] = tile;
		 		}
		 		if (addMeshTerrainToScene){
		 			 VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol].meshTerrain = new THREE.Mesh(geom,new THREE.MeshFaceMaterial(VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol].texturesManager.materialsArray))
					 VCC.ViewPort.scene.add(VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol].meshTerrain);
		 		}
		 		if (addMeshBuildingsToScene){
		 			VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol].meshBuilding = new THREE.Mesh(geom,new THREE.MeshFaceMaterial(VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol].texturesManager.materialsArray))
					VCC.ViewPort.scene.add(VCC.ViewPort.tileManager.tabTile[tileRow+&quot;_&quot;+tileCol].meshBuilding);
		 		}
			},
			error: function(jqhr, status, errorThrown){
				console.log(&quot;error : &quot;+ errorThrown );
			},
			complete: function(){
				VCC.ViewPort.tileManager.scheduler.onTaskDone();
			}

		});
};

/**
* Create geometries and UV mapping for buildings
* @method createGeometries
* @param {String} jsonDataList Json List of items to be created
* @param {VCC.TexturesManager} texturesManager TexturesManager of the tile we are creating
* @param {Array} indexMaterialList List of index material (from VCC.Tile)
* @return {THREE.Geometry} geom Merged geometry of the tile layer
*/

VCC.TileManager.prototype.createGeometries = function(jsonDataList, texturesManager, indexMaterialList){
	var geom = new THREE.Geometry();
	for(w in jsonDataList){
		if (w !== &quot;nbFace&quot;){

			/** For each par of the wall we vreate vertices and faces thar we push in the geometry */
			var wallGeom = new THREE.Geometry();
			var nbVertices = (jsonDataList[w].listGeometries.length)/3;
			for(var v = 0 ; v &lt; nbVertices; v++ ){
				var offset = v*3;
				var vertice = new THREE.Vector3();
				vertice.setX((jsonDataList[w].listGeometries[offset] ) - VCC.ViewPort.tileManager.BBMin[0] - VCC.ViewPort.offsetPosition.x );
				vertice.setY((jsonDataList[w].listGeometries[offset+2])- VCC.ViewPort.tileManager.BBMin[2]);
									vertice.setZ((jsonDataList[w].listGeometries[offset+1])- VCC.ViewPort.tileManager.BBMin[1] - VCC.ViewPort.offsetPosition.z );  //!\\ y is up
									wallGeom.vertices.push(vertice);
			};
			var nbTri = (jsonDataList[w].listIndices.length)/3;
			for(var f = 0; f &lt; nbTri ;f++)
			{
				var offset = f*3;

				var offsetUVs1 = jsonDataList[w].listIndices[offset]*2;
				var offsetUVs2 = jsonDataList[w].listIndices[offset+1]*2;
				var offsetUVs3 = jsonDataList[w].listIndices[offset+2]*2;

				var face = new THREE.Face3();

				face.a = jsonDataList[w].listIndices[offset];
				face.b = jsonDataList[w].listIndices[offset+1];
				face.c = jsonDataList[w].listIndices[offset+2];
				face.normal = new THREE.Vector3(
					jsonDataList[w].listNormals[offset],
					jsonDataList[w].listNormals[offset+1],
					jsonDataList[w].listNormals[offset+2]);
				face.materialIndex = texturesManager.getIndexMaterial(jsonDataList[w].texture, indexMaterialList);
				wallGeom.faces.push(face);
				/** Uv Mapping creation  (try to map index of vertice into listUVs)*/
				wallGeom.faceVertexUvs[0].push([
					new THREE.Vector2(jsonDataList[w].listUVs[offsetUVs1], jsonDataList[w].listUVs[offsetUVs1+1]),
					new THREE.Vector2(jsonDataList[w].listUVs[offsetUVs2], jsonDataList[w].listUVs[offsetUVs2+1]),
					new THREE.Vector2(jsonDataList[w].listUVs[offsetUVs3], jsonDataList[w].listUVs[offsetUVs3+1])
					]);
			}
			geom.merge(wallGeom);
		}
	}
	return geom;
};

/**
* Delete a tile
* @method deleteTile
* @param {int} idTile Id of the tile we want to delete
*/

VCC.TileManager.prototype.deleteTile = function(idTile)
{
	console.log(&quot;deleting tile &quot; + idTile);
	if(this.tileExist(idTile)){
		if (VCC.ViewPort.tileManager.tabTile[idTile].meshTerrain !== undefined){
			VCC.ViewPort.scene.remove(VCC.ViewPort.tileManager.tabTile[idTile].meshTerrain);
			VCC.ViewPort.tileManager.tabTile[idTile].meshTerrain.geometry.dispose();
			VCC.ViewPort.tileManager.tabTile[idTile].texturesManager.disposeMaterials(VCC.ViewPort.tileManager.tabTile[idTile].indexTerrainMaterialList);
		}
		if (VCC.ViewPort.tileManager.tabTile[idTile].meshBuilding !== undefined){
			VCC.ViewPort.scene.remove(VCC.ViewPort.tileManager.tabTile[idTile].meshBuilding);
			VCC.ViewPort.tileManager.tabTile[idTile].meshBuilding.geometry.dispose();
			VCC.ViewPort.tileManager.tabTile[idTile].texturesManager.disposeMaterials(VCC.ViewPort.tileManager.tabTile[idTile].indexBuildingMaterialList);
			VCC.ViewPort.tileManager.tabTile[idTile].texturesManager.disposeMaterials(VCC.ViewPort.tileManager.tabTile[idTile].indexTerrainMaterialList);
		}
		delete VCC.ViewPort.tileManager.tabTile[idTile];
	}
};

/**
* Calculate the current LOD and trigger reloadWithNewLod()
* @method lodChange
*/

VCC.TileManager.prototype.lodChange = function(){
	var y = parseInt(VCC.ViewPort.camera.position.y);

	var lod = parseInt(y/300);
	//if the LOD change
	if(lod !== this.sceneLod)
	{
		this.previousLod = this.sceneLod;
		this.sceneLod = lod;
		//this.reloadWithNewLod();
	}
};

/**
* Calculate the main tile (where the camera belongs) and triger the tilePriorityManager to remove far tiles
* @method updateMainTile
*/

VCC.TileManager.prototype.updateMainTile = function()
{

	var posX, posZ, mTileX, mTileY;
	posX = Math.floor((VCC.ViewPort.camera.position.x + VCC.ViewPort.offsetPosition.x )/this.sizeTile) + this.firstTileX;
	posZ = Math.floor((VCC.ViewPort.camera.position.z + VCC.ViewPort.offsetPosition.z )/this.sizeTile) + this.firstTileY;
	mTileX = posX;
	mTileY = posZ;

	if(mTileX !== this.mainTileX || mTileY !== this.mainTileY)
	{

 		//this.cleanBuildings(this.mainTileX+&quot;_&quot;+this.mainTileY);
		this.mainTileX = mTileX;
		this.mainTileY = mTileY;

		//this.createTile(mTileX, mTileY,&quot;build&quot;,true);

		this.deleteObjetOutOfScene();
		this.tilePriorityManager();
	}
};

/**
* Check if the tile coordinates given in arguments are in view of the camera
* @method isInSquare
* @return {Boolean}
*/

VCC.TileManager.prototype.isInSquare = function (X, Y)
{
	if(X &lt;= this.mainTileX + this.rangeCameraTile &amp;&amp; X &gt;= this.mainTileX - this.rangeCameraTile &amp;&amp; Y &lt;= this.mainTileY + this.rangeCameraTile  &amp;&amp; Y &gt;= this.mainTileY - this.rangeCameraTile)
	{
		return true;
	}
	return false;
};


/**
* Trigger the deleteTile function if a tile is detected as out of view
* @method isInSquare
*/

VCC.TileManager.prototype.deleteObjetOutOfScene = function()
{
	var coord;
	for(var idTile in this.tabTile)
	{
		coord = idTile.split(&#x27;_&#x27;);
		if(!this.isInSquare(coord[0], coord[1]))
		{
			this.scheduler.removeFifo.push(coord);
		}
	}
};

/**
* Remove only Building of a tile
*
*@method cleanBuildings
*@param {String} idTile Id of the tile we want to clean buildings on.
*/

VCC.TileManager.prototype.cleanBuildings = function(idTile){
	if (this.tileExist(idTile)){
		VCC.ViewPort.scene.remove(VCC.ViewPort.tileManager.tabTile[idTile].meshBuilding);
		VCC.ViewPort.tileManager.tabTile[idTile].meshBuilding.geometry.dispose();
		VCC.ViewPort.tileManager.tabTile[idTile].meshBuilding = new THREE.Mesh(new THREE.Geometry(),new THREE.MeshFaceMaterial(VCC.ViewPort.tileManager.tabTile[idTile].texturesManager.materialsArray));
		VCC.ViewPort.tileManager.tabTile[idTile].texturesManager.disposeMaterials(VCC.ViewPort.tileManager.tabTile[idTile].indexBuildingMaterialList,VCC.ViewPort.tileManager.tabTile[idTile].indexTerrainMaterialList);
		VCC.ViewPort.tileManager.tabTile[idTile].hasBuildings = false;
	}
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
